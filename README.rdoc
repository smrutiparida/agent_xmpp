= Agent XMPP

Agent XMPP is a simple DSL for writing XMPP bots that respond to Ad-Hoc Commands.
Ad-Hoc Commands are described in XMPP extension XEP-0050 (see http://xmpp.org/extensions/xep-0050.html).

    # mybot.rb
    require 'rubygems'
    require 'agent_xmpp'

    execute 'hello' do
      'Hello World' 
    end

Specify the agent Jabber ID (JID), password and roster in agent_xmpp.yml.

    jid: mybot@nowhere.com
    password: pass
    roster:
        - you@home.com
        - someone@somewhere.com

Install the gem and run

    sudo gem install troystribling-agent_xmpp --source=http://gems.github.com
    ruby mybot.rb

Request and response payloads use the jabber:x:data protocol described in XMPP extension 
XEP-0004 (see http://xmpp.org/extensions/xep-0004.html).

When first started mybot.rb will automatically send buddy requests to all contacts specified
in the agent_xmpp.yml. Accept the buddy request and send commands.

mybot.rb will respond to the request,

    <iq id='5644' to='mybot@nowhere.com/mybot-host' type='set' xmlns='jabber:client'>
        <command node='hello' action='execute' xmlns='http://jabber.org/protocol/commands'/>
    </iq>
    
with

    <iq from='mybot@nowhere.com/mybot-host' to='you@home.com/your-host' id='5644' type='result' xmlns='jabber:client'>
        <command node='hello' status='completed' xmlns='http://jabber.org/protocol/commands'>
            <x type='result' xmlns='jabber:x:data'>
                <field><value>Hello World</value></field>
            </x>
        </command>
    </iq>    

== Response Payloads

Agent XMPP supports mapping scalars, arrays and hashes to jabber:x:data payloads

    execute 'scalar' do
      'scalar' 
    end

    execute 'hash' do
      {:attr1 => 'val1', :attr2 => 'val2'}
    end

    execute 'scalar_array' do
      ['val1', 'val2','val3', 'val4'] 
    end

    execute 'hash_array' do
      {:attr1 => ['val11', 'val11'], :attr2 => 'val12'}
    end

    execute 'array_hash' do
      [{:attr1 => 'val11', :attr2 => 'val12'}, 
       {:attr1 => 'val21', :attr2 => 'val22'}, 
       {:attr1 => 'val31', :attr2 => 'val32'}]
    end

    execute 'array_hash_array' do
      [{:attr1 => ['val11', 'val11'], :attr2 => 'val12'}, 
       {:attr1 => ['val21', 'val21'], :attr2 => 'val22'}, 
       {:attr1 => ['val31', 'val31'], :attr2 => 'val32'}]
    end

== Application Startup Callbacks

Startup callback methods are available to applications 

    before_start{}

    after_connected{|pipe|}

    restarting_client{|pipe|}
    
    discovered_user_pubsub_node{|pipe|}

== Logging

By default log messages are written to STDOUT. A log file can be specified with the -l option.

    ruby mybot.rb -l file.log

The logger can be accessed and configured.

    AgentXmpp.logger.level = Logger::WARN 

== Message Processing Callbacks

Message processing callbacks are available to applications and should be implemented in a delegate module. 

    AgentXmpp::Boot.after_connected do |pipe|
      pipe.add_delegate(YourDelegate)
    end

The available callback methods are,

=== Connection

    did_connect(pipe)

    did_disconnect(pipe)

    did_not_connect(pipe)

=== Authentication

    did_bind(pipe)

    did_receive_pre_authenticate_features(pipe)

    did_authenticate(pipe)

    did_not_authenticate(pipe)

    did_receive_post_authenticate_features(pipe)

    did_start_session(pipe)

=== Presence

    did_receive_presence(pipe, presence)

    did_receive_presence_subscribe(pipe, presence)

    did_receive_presence_subscribed(pipe, presence)

    did_receive_presence_unavailable(pipe, presence)

    did_receive_presence_unsubscribed(pipe, presence)

=== Roster

    did_receive_roster_result(pipe, stanza)

    did_receive_roster_set(pipe, stanza)

    did_receive_roster_item(pipe, roster_item)

    did_remove_roster_item(pipe, roster_item)

    did_receive_all_roster_items(pipe)

    did_acknowledge_add_roster_item(pipe, response)

    did_acknowledge_remove_roster_item(pipe, response)

    did_receive_remove_roster_item_error(pipe, response)

    did_receive_add_roster_item_error(pipe, response)

=== Service Discovery

    did_receive_version_result(pipe, version)

    did_receive_version_get(pipe, request)

    did_receive_version_error(pipe, error)
    
    did_receive_discoinfo_result(pipe, discoinfo)
    
    did_receive_discoinfo_get(pipe, request) 

    did_receive_discoinfo_error(pipe, error)
    
    did_receive_discoitems_result(pipe, discoitems)
    
    did_receive_discoitems_get(pipe, request)

    did_receive_discoitems_error(pipe, error)
            
=== Applications

    did_receive_command_set(pipe, stanza)

    did_receive_message_chat(pipe, stanza)

=== PubSub

    did_acknowledge_publish(pipe, result, node)

    did_receive_publish_error(pipe, result, node)

    did_discover_pupsub_service(pipe, jid, ident)
    
    did_discover_pupsub_category(pipe, jid, node)
      
    did_discover_pupsub_leaf(pipe, jid, node)

    did_receive_pusub_subscriptions_result(pipe, result)
    
    did_receive_pusub_subscriptions_error(pipe, result)

    did_receive_pusub_affiliations_result(pipe, result)
    
    did_receive_pusub_affiliations_error(pipe, result)

    did_discover_user_pubsub_node(pipe, result)
    
    did_receive_create_user_node_result(pipe, node, result)    

    did_receive_create_user_node_error(pipe, node, result)    
    
=== ERRORS

    did_receive_unsupported_message(pipe, stanza)

== Copyright

Copyright (c) 2009 Troy Stribling. See LICENSE for details.
