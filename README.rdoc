= Agent XMPP

Agent XMPP is a simple DSL for writing XMPP clients that support Messaging, Ad-Hoc Commands and Publish Subscribe 
Events. An application that responds to an Ad-Hoc command can be written with as few as five lines of code.

    # myapp.rb
    require 'rubygems'
    require 'agent_xmpp'

    execute 'hello' do
      'Hello World' 
    end

Specify the application Jabber ID (JID), password and roster in agent_xmpp.yml.

    jid: myapp@nowhere.com
    password: pass
    roster:
        - 
            jid:you@home.com
        - 
            jid: someone@somewhere.com

Install the gem and run

    sudo gem install troystribling-agent_xmpp --source=http://gems.github.com
    ruby myapp.rb

Request and response payloads use the jabber:x:data protocol described in XMPP extension 
XEP-0004.

When first started myapp.rb will automatically send buddy requests to all contacts specified
in the agent_xmpp.yml. You should accept the buddy request and send a command.

myapp.rb will respond to the command,

    <iq id='5644' to='mybot@nowhere.com/mybot-host' type='set' xmlns='jabber:client'>
        <command node='hello' action='execute' xmlns='http://jabber.org/protocol/commands'/>
    </iq>
    
with

    <iq from='myapp@nowhere.com/myapp-host' to='you@home.com/your-host' id='5644' type='result' xmlns='jabber:client'>
        <command node='hello' status='completed' xmlns='http://jabber.org/protocol/commands'>
            <x type='result' xmlns='jabber:x:data'>
                <field><value>Hello World</value></field>
            </x>
        </command>
    </iq>    

== Response Payload

Agent XMPP will automatically map scalars, arrays and hashes returned by execute blocks to jabber:x:data command 
response payloads.  

    execute 'scalar' do
      'scalar' 
    end

    execute 'hash' do
      {:a1 => 'v1', :a2 => 'v2'}
    end

    execute 'scalar_array' do
      ['v1', 'v2','v3', 'v4'] 
    end

    execute 'hash_array' do
      {:a1 => ['v11', 'v11'], :a2 => 'v12'}
    end

    execute 'array_hash' do
      [{:a1 => 'v11', :a2 => 'v12'}, 
       {:a1 => 'v21', :a2 => 'v22'}, 
       {:a1 => 'v31', :a2 => 'v32'}]
    end

    execute 'array_hash_array' do
      [{:a1 => ['v11', 'v11'], :a2 => 'v12'}, 
       {:a1 => ['v21', 'v21'], :a2 => 'v22'}, 
       {:a1 => ['v31', 'v31'], :a2 => 'v32'}]
    end

a params structure is available within the execute block containing routing information.

== Send Command

Commands may be sent with or without a response callback,

    command(:to=>'thatapp@a-place.com/ahost', :node=> 'hello') do |status, data|
      AgentXmpp.logger.info "COMMAND RESPONSE: #{status}, #{data.inspect}"
    end

    command(:to=>'thatapp@a-place.com/ahost', :node=> 'bye')

and within execute blocks.

    execute 'hash_hello' do
      command(:to=>params[:from], :node=> 'hello') do |status, data|
        AgentXmpp.logger.info "COMMAND RESPONSE: #{status}, #{data.inspect}"
      end
      {:a1 => 'v1', :a2 => 'v2'}
    end

== Send Messages

    message(:to=>'thatapp@a-place.com/ahost', :body=>"Hello from #{AgentXmpp.jid.to_s} at " + Time.now.to_s)
    
== Publish Subscribe

Publish nodes are configured in agent_xmpp.yml.

    jid: myapp@nowhere.com
    password: pass
    roster:
        - 
            jid:you@home.com
        - 
            jid: someone@somewhere.com
    publish:
        - 
            node: time
            title: "Curent Time"   
        - 
            node: alarm
            title: "Alarms"   

The nodes are created if they do not exist and publish methods are generated for each node.

    publish_time('The time is:' + Time.now.to_s)
    
    publish_alarm({:severity => :major, :description => "A really bad failure"})

Publish nodes discovered that are not provisioned in agent_xmpp.yml will be deleted.

To receive events declare event blocks in myapp.rb.

    # myapp.rb
    require 'rubygems'
    require 'agent_xmpp'

    event 'someone@somewhere.com', 'time' do
      message(:to=>'someone@somewhere.com', :body=>"Got the event at: " + Time.now.to_s)
    end

Agent XMPP will automatically verify the subscription to the event and subscribe if required. Subscriptions
discovered that are not declared by an event block in the application will be deleted.

== Major Event Callbacks

Agent XMPP provides callbacks for applications to respond to major events that occur during execution.
 
    # application starting
    before_start{}

    # connected to server
    after_connected{|connection|}

    # client restarts when disconnected form server
    restarting_client{|connection|}
    
    # all configured publish nodes have been discovered
    discovered_all_publish_nodes{}

    # a pubsub node was discovered at service
    discovered_pubsub_node{|service, node|}
    
    # command nodes were discovered at jid
    discovered_command_nodes{|jid, nodes|}

    # a presence message of status :available or :unavailable was received from jid
    received_presence{|from, status|}
    
== Authentication
    
* Basic SASL

== Development with XMPP Clients

None of Ad-Hoc Commands, jabber:x:data Forms nor Service Discovery are widely supported by XMPP clients and Publish-Subscribe 
is not supported. Gajim http://www.gajim.org/Psi provides support for Ad-Hoc Commands and jabber:x:data Forms. Service Discovery,
which is useful for Publish-Subscibe development, is supported by Gajim but is buggy, Psi http://psi-im.org/ provides good much better
support. Both Gajim and Psi provide an interface for manual entry of XML messages which is required for Publish-Subscribe development.

== Logging

    By default log messages are written to STDOUT. A log file can be specified with the -l option.

        ruby mybot.rb -l file.log

    The logger can be accessed and configured.
        
        before_start do
          AgentXmpp.logger.level = Logger::WARN 
        end

== Supported XEPs

    XEP-0004 jabber:x:data Forms    http://xmpp.org/extensions/xep-0004.html
    XEP-0030 Service Discovery      http://xmpp.org/extensions/xep-0030.html
    XEP-0050 Ad-Hoc Commands        http://xmpp.org/extensions/xep-0050.html
    XEP-0060 Publish Subscribe      http://xmpp.org/extensions/xep-0060.html
    XEP-0092 Software Version       http://xmpp.org/extensions/xep-0092.html

== Message Processing Callbacks

Message processing callbacks are available to applications to extend the message processing work flow. To receive
callbacks a delegate object must be provided.   

    after_connected do |connection|
      connection.add_delegate(YourDelegate)
    end

The available callback methods are,

=== Connection

    did_connect(connection)

    did_disconnect(connection)

    did_not_connect(connection)

=== Authentication

    did_bind(connection)

    did_receive_pre_authenticate_features(connection)

    did_authenticate(connection)

    did_not_authenticate(connection)

    did_receive_post_authenticate_features(connection)

    did_start_session(connection)

=== Presence

    did_receive_presence(connection, presence)

    did_receive_presence_subscribe(connection, presence)

    did_receive_presence_subscribed(connection, presence)

    did_receive_presence_unavailable(connection, presence)

    did_receive_presence_unsubscribed(connection, presence)

=== Roster

    did_receive_roster_result(connection, stanza)

    did_receive_roster_set(connection, stanza)

    did_receive_roster_item(connection, roster_item)

    did_remove_roster_item(connection, roster_item)

    did_receive_all_roster_items(connection)

    did_receive_update_roster_item_result(connection, response)

    did_receive_remove_roster_item(connection, response)

    did_receive_remove_roster_item_error(connection, response)

    did_receive_update_roster_item_error(connection, response)

=== Service Discovery

    did_receive_version_result(connection, version)

    did_receive_version_get(connection, request)

    did_receive_version_error(connection, error)
    
    did_receive_discoinfo_result(connection, discoinfo)
    
    did_receive_discoinfo_get(connection, request) 

    did_receive_discoinfo_error(connection, error)
    
    did_receive_discoitems_result(connection, discoitems)
    
    did_receive_discoitems_get(connection, request)

    did_receive_discoitems_error(connection, error)
            
=== Applications

    did_receive_command_set(connection, stanza)

    did_receive_message_chat(connection, stanza)

    did_receive_message_normal(connection, stanza)

    did_receive_pubsub_event(connection, event, to, from)

=== PubSub

    did_acknowledge_publish(connection, result, node)

    did_receive_publish_error(connection, result, node)

    did_discover_pubsub_service(connection, jid, ident)
    
    did_discover_pubsub_collection(connection, jid, node)
      
    did_discover_pubsub_leaf(connection, jid, node)

    did_receive_pubsub_subscriptions_result(connection, result)
    
    did_receive_pubsub_subscriptions_error(connection, result)

    did_receive_pubsub_affiliations_result(connection, result)
    
    did_receive_pubsub_affiliations_error(connection, result)

    did_discover_user_pubsub_node(connection, result)
    
    did_receive_create_node_result(connection, node, result)    

    did_receive_create_node_error(connection, node, result)    

    did_receive_pubsub_subscribe_result(connection, result, node) 

    did_receive_pubsub_subscribe_error(connection, result, node) 

    did_receive_pubsub_subscribe_error_item_not_found(connection, result, node) 

    did_receive_pubsub_unsubscribe_result(connection, result, node) 

    did_receive_pubsub_unsubscribe_error(connection, result, node) 
    
=== ERRORS

    did_receive_unsupported_message(connection, stanza)

== Copyright

Copyright (c) 2009 Troy Stribling. See LICENSE for details.
